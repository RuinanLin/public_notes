# 练习10：字符串数组和循环　习题解答

## 整理人：林睿楠

* 让这些循环倒序执行，通过使用`i--`从`argc`开始递减直到0．你可能需要做一些算数操作让数组的下标正常工作．

	基于示例，改动如下：

	```
	6,7c6,7
	< 	int i = 0;
	< 	while (i < argc) {
	---
	> 	int i = argc - 1;
	> 	while (i >= 0) {
	9c9
	< 		i++;
	---
	> 		i--;
	19,20c19,20
	< 	i = 0;	// watch for this
	< 	while (i < num_states) {
	---
	> 	i = num_states - 1;	// watch for this
	> 	while (i >= 0) {
	22c22
	< 		i++;
	---
	> 		i--;
	```

	以`./build/ex11-1 test it`为输入，得到的运行结果如下：

	```
	arg 2: it
	arg 1: test
	arg 0: ./build/ex11-1
	state 3: Texas
	state 2: Washington
	state 1: Oregon
	state 0: California
	```

	符合预期．<br><br>

* 使用`while`循环将`argv`中的值复制到`states`．

	这里还需要加一下大小判断，以免复制的时候越界．基于所给代码的改动如下：

	```
	24a25,41
	> 	// copy from argv to states
	> 	int num_copied_elems = (argc < num_states) ? argc : num_states;
	> 	i = 0;
	> 	while (i < num_copied_elems) {
	> 		states[i] = argv[i];
	> 		i++;
	> 	}
	> 
	> 	// display copied results
	> 	printf("-------------------------\n");
	> 	printf("states[] after copying from argv[]\n");
	> 	i = 0;
	> 	while (i < num_states) {
	> 		printf("state %d: %s\n", i, states[i]);
	> 		i++;
	> 	}
	> 
	```

	很直观，就是赋值再打印．

	如果输入是`./build/ex11-2 test it`，结果如下：

	```
	arg 0: ./build/ex11-2
	arg 1: test
	arg 2: it
	state 0: California
	state 1: Oregon
	state 2: Washington
	state 3: Texas
	-------------------------
	states[] after copying from argv[]
	state 0: ./build/ex11-2
	state 1: test
	state 2: it
	state 3: Texas
	```

	而如果输入是`./build/ex11-2 test it again and again`，则结果如下：

	```
	arg 0: ./build/ex11-2
	arg 1: test
	arg 2: it
	arg 3: again
	arg 4: and
	arg 5: again
	state 0: California
	state 1: Oregon
	state 2: Washington
	state 3: Texas
	-------------------------
	states[] after copying from argv[]
	state 0: ./build/ex11-2
	state 1: test
	state 2: it
	state 3: again
	```

	结果符合预期．<br><br>

* 让这个复制循环不会执行失败，即使`argv`之中有很多元素也不会全部放进`states`．

	在做上一题的时候，没有注意到这一题，在做上一题的时候已经完成了这样的安全保障．

* 研究你是否真正复制了这些字符串．答案可能会让你感到意外和困惑．

	并没有真正复制，作为二周目玩家也并不困惑．

	这些字符串是只读的，在ELF文件中存储在`.rodata`段．这些数组保存的也只是指向这些字符串的指针．复制的也只是指针而已，指向的是同一个字符串．

	基于刚刚的`ex11-2.c`，可以通过如下修改进行验证：

	```
	41a42,59
	> 	// display argv[] elems as pointers
	> 	printf("-------------------------\n");
	> 	printf("display argv[] elems as pointers\n");
	> 	i = 0;
	> 	while (i < argc) {
	> 		printf("arg %d: %p\n", i, argv[i]);
	> 		i++;
	> 	}
	> 
	> 	// display states[] elems as pointers
	> 	printf("-------------------------\n");
	> 	printf("display states[] elems as pointers\n");
	> 	i = 0;
	> 	while (i < num_states) {
	> 		printf("state %d: %p\n", i, states[i]);
	> 		i++;
	> 	}
	> 
	```

	以`./build/ex11-4 test it again and again`为输入，得到的结果如下：

	```
	arg 0: ./build/ex11-4
	arg 1: test
	arg 2: it
	arg 3: again
	arg 4: and
	arg 5: again
	state 0: California
	state 1: Oregon
	state 2: Washington
	state 3: Texas
	-------------------------
	states[] after copying from argv[]
	state 0: ./build/ex11-4
	state 1: test
	state 2: it
	state 3: again
	-------------------------
	display argv[] elems as pointers
	arg 0: 0x7fff57d6eee0
	arg 1: 0x7fff57d6eeef
	arg 2: 0x7fff57d6eef4
	arg 3: 0x7fff57d6eef7
	arg 4: 0x7fff57d6eefd
	arg 5: 0x7fff57d6ef01
	-------------------------
	display states[] elems as pointers
	state 0: 0x7fff57d6eee0
	state 1: 0x7fff57d6eeef
	state 2: 0x7fff57d6eef4
	state 3: 0x7fff57d6eef7
	```

	可以看出，指针是相同的．
