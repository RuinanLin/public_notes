# 练习17：堆和栈的内存分配　习题解答

## 整理人：林睿楠

在完成附加题之前，首先需要改掉原本程序中的bug：`strncpy`的设计缺陷。如果`name`或者`address`超过了512个字节，那么`strncpy`不会自动补全一个`'\0'`，这样，如果访问字符串的话，会访问到不属于该字符串的东西，因此需要给最后一个字符强制设置成`'\0'`，进行截断。改动后的代码部分如下：

```c
void Database_set(struct Connection *conn, int id, const char *name, const char *email)
{
	struct Address *addr = &conn->db->rows[id];
	if(addr->set) die("Already set, delete it first");

	addr->set = 1;
	char *res = strncpy(addr->name, name, MAX_DATA);
	addr->name[MAX_DATA-1] = '\0';
	if(!res) die("Name copy failed");

	res = strncpy(addr->email, email, MAX_DATA);
	addr->email[MAX_DATA-1] = '\0';
	if(!res) die("Email copy failed");
}
```

### `die`函数需要接收`conn`变量作为参数，以便执行清理并关闭它。

基于`ex17.c`，做以下改动，生成`ex17-1.c`：

```diff
26c26,28
< void die(const char *message)
---
> void Database_close(struct Connection *conn);
> 
> void die(const char *message, struct Connection *conn)
33a36
> 	Database_close(conn);
46c49
< 	if(rc != 1) die("Failed to load database.");
---
> 	if(rc != 1) die("Failed to load database.", conn);
52c55
< 	if(!conn) die("Memory error");
---
> 	if(!conn) die("Memory error", conn);
55c58
< 	if(!conn->db) die("Memory error");
---
> 	if(!conn->db) die("Memory error", conn);
67c70
< 	if(!conn->file) die("Failed to open the file");
---
> 	if(!conn->file) die("Failed to open the file", conn);
86c89
< 	if(rc != 1) die("Failed to write database.");
---
> 	if(rc != 1) die("Failed to write database.", conn);
89c92
< 	if(rc == -1) die("Cannot flush database.");
---
> 	if(rc == -1) die("Cannot flush database.", conn);
107c110
< 	if(addr->set) die("Already set, delete it first");
---
> 	if(addr->set) die("Already set, delete it first", conn);
112c115
< 	if(!res) die("Name copy failed");
---
> 	if(!res) die("Name copy failed", conn);
116c119
< 	if(!res) die("Email copy failed");
---
> 	if(!res) die("Email copy failed", conn);
126c129
< 		die("ID is not set");
---
> 		die("ID is not set", conn);
152c155
< 	if(argc < 3) die("USAGE: ex17 <dbfile> <action> [action params]");
---
> 	if(argc < 3) die("USAGE: ex17 <dbfile> <action> [action params]", NULL);
160c163
< 	if(id >= MAX_ROWS) die("There's not that many records.");
---
> 	if(id >= MAX_ROWS) die("There's not that many records.", conn);
169c172
< 			if(argc != 4) die("Need an id to get");
---
> 			if(argc != 4) die("Need an id to get", conn);
175c178
< 			if(argc != 6) die("Need id, name, email to set");
---
> 			if(argc != 6) die("Need id, name, email to set", conn);
182c185
< 			if(argc != 4) die("Need id to delete");
---
> 			if(argc != 4) die("Need id to delete", conn);
192c195
< 			die("Invalid action, only: c=create, g=get, s=set, d=del, l=list");
---
> 			die("Invalid action, only: c=create, g=get, s=set, d=del, l=list", conn);
```

主要的改动概括如下：

1. 在`die()`函数的定义中加入`struct Connection *conn`作为参数，并在函数末尾加操作`Database_close(conn)`；
2. 因为`Database_close()`函数在文件中定义在`die()`函数后面，所以需要在`die()`函数的前面声明`Database_close()`函数；
3. 在每一处调用`die()`函数的地方加入参数`conn`，其中`main`函数参数不够的`die()`，因为还没有创建`conn`，所以传入`NULL`即可，因为`Database_close()`会自己判断`NULL`的情况。

### 修改代码，使其接收参数作为`MAX_DATA`和`MAX_ROWS`，将它们存储在`Database`结构体中，并且将它们写到文件。这样就可以创建任意大小的数据库。

本题，我基于`ex17-1.c`修改，得到了`ex17-2.c`。因修改幅度过大，此处只挑选重点部分讲解。

1. **数据结构设计**
    
    因为数据库的行数和数据最长尺寸都变了，所以没有办法通过提前分配数组来实现，只能通过后续根据命令行参数动态分配内存。新的数据结构设计如下：

    ```c
    struct Address {
        int id;
        int set;
        char *name;
        char *email;
    };

    struct Database {
        int num_rows;
        int data_size;
        struct Address *rows;
    };

    struct Connection {
        FILE *file;
        struct Database *db;
    };
    ```

    就是把`name`、`email`、`rows`设计成指针，并把数据库行数`num_rows`和数据尺寸`data_size`记录到`Database`当中。

2. **动态分配内存函数设计**

    设计了一个新函数。在此函数调用时，`conn->db`已经分配了内存，此函数的功能是：根据提供的数据库行数`num_rows`和数据尺寸`data_size`，为`conn->db`中的`rows`及其内部的每一个`Address`分配相应大小的内存空间。

    ```c
    void Database_alloc(struct Connection *conn, int num_rows, int data_size) {
        if (!conn || !conn->db) die("conn->db should be allocated before calling Database_alloc", conn);

        conn->db->num_rows = num_rows;
        conn->db->data_size = data_size;
        conn->db->rows = malloc(num_rows * sizeof(struct Address));
        if (!conn->db->rows) die("Memory error", conn);

        for (int i = 0; i < num_rows; i++) {
            conn->db->rows[i].name = malloc(data_size * sizeof(char));
            if (!conn->db->rows[i].name) die("Memory error", conn);

            conn->db->rows[i].email = malloc(data_size * sizeof(char));
            if (!conn->db->rows[i].email) die("Memory error", conn);
        }
    }
    ```

3. **修改`Database_load`**

    加载数据不能简单地进行直接复制了。首先，需要从文件中读取`num_rows`和`data_size`这两个元数据，调用`Database_alloc`为数据库分配内存空间。此后，因为`name`和`email`也不定长了，需要一行一行地按照要求进行拷贝。代码实现如下：

    ```c
    void Database_load(struct Connection *conn)
    {
        int num_rows = 0;
        int rc = fread(&num_rows, sizeof(int), 1, conn->file);
        if (rc != 1) die("Failed to load database num_rows.", conn);
        if (num_rows < 0) die("Invalid database format: negative num_rows.", conn);
        
        int data_size = 0;
        rc = fread(&data_size, sizeof(int), 1, conn->file);
        if (rc != 1) die("Failed to load database data_size.", conn);
        if (data_size < 0) die("Invalid database format: negative data_size.", conn);

        Database_alloc(conn, num_rows, data_size);

        for (int i = 0; i < conn->db->num_rows; i++) {
            rc = fread(&conn->db->rows[i].id, sizeof(int), 1, conn->file); if (rc != 1) die("Failed to load row id.", conn);
            rc = fread(&conn->db->rows[i].set, sizeof(int), 1, conn->file); if (rc != 1) die("Failed to load row set.", conn);
            rc = fread(conn->db->rows[i].name, conn->db->data_size * sizeof(char), 1, conn->file); if (rc != 1) die("Failed to load row name.", conn);
            rc = fread(conn->db->rows[i].email, conn->db->data_size * sizeof(char), 1, conn->file); if (rc != 1) die("Failed to load row email.", conn);
        }
    }
    ```

4. **修改`Database_close`**

    也是一个一个地进行释放，实现如下：

    ```c
    void Database_close(struct Connection *conn)
    {
        if(conn) {
            if(conn->file) fclose(conn->file);

            if (conn->db) {
                if (conn->db->rows) {
                    for (int i = 0; i < conn->db->num_rows; i++) {
                        if (conn->db->rows[i].name) free(conn->db->rows[i].name);
                        if (conn->db->rows[i].email) free(conn->db->rows[i].email);
                    }
                    free(conn->db->rows);
                }
                free(conn->db);
            }

            free(conn);
        }
    }
    ```

5. **修改`Database_write`**

    也是按照之前约定的格式写文件：

    ```c
    void Database_write(struct Connection *conn)
    {
        rewind(conn->file);

        int rc = fwrite(&conn->db->num_rows, sizeof(int), 1, conn->file);
        if (rc != 1) die("Failed to write num_rows.", conn);

        rc = fwrite(&conn->db->data_size, sizeof(int), 1, conn->file);
        if (rc != 1) die("Failed to write data_size.", conn);

        for (int i = 0; i < conn->db->num_rows; i++) {
            rc = fwrite(&conn->db->rows[i].id, sizeof(int), 1, conn->file);
            if (rc != 1) die("Failed to write id.", conn);

            rc = fwrite(&conn->db->rows[i].set, sizeof(int), 1, conn->file);
            if (rc != 1) die("Failed to write set.", conn);

            rc = fwrite(conn->db->rows[i].name, conn->db->data_size * sizeof(char), 1, conn->file);
            if (rc != 1) die("Failed to write name.", conn);

            rc = fwrite(conn->db->rows[i].email, conn->db->data_size * sizeof(char), 1, conn->file);
            if (rc != 1) die("Failed to write email.", conn);
        }
        
        rc = fflush(conn->file);
        if(rc == -1) die("Cannot flush database.", conn);
    }
    ```

其他的细节就不仔细介绍了，不是关键部分。

### 向数据库添加更多操作，比如`find`。

在`ex17-2.c`的基础上实现了`ex17-3.c`，细节不罗列，主要是实现了`Database_find`函数：

```c
void Database_find(struct Connection *conn, char *name) {
	int found = 0;

	for (int i = 0; i < conn->db->num_rows; i++) {
		struct Address *addr = &conn->db->rows[i];
		if (addr->set && strcmp(addr->name, name) == 0) {
			Address_print(addr);
			found = 1;
		}
	}

	if (!found) {
		printf("No record found for %s\n", name);
	}
}
```

逻辑就是一条一条比对，没找到就说没找到。